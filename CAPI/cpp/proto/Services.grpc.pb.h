// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: Services.proto
#ifndef GRPC_Services_2eproto__INCLUDED
#define GRPC_Services_2eproto__INCLUDED

#include "Services.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

#undef SendMessage

namespace protobuf
{

    class AvailableService final
    {
    public:
        static constexpr char const* service_full_name()
        {
            return "protobuf.AvailableService";
        }
        class StubInterface
        {
        public:
            virtual ~StubInterface()
            {
            }
            virtual ::grpc::Status TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncTryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncTryConnectionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncTryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncTryConnectionRaw(context, request, cq));
            }
            // 游戏开局调用一次的服务
            std::unique_ptr<::grpc::ClientReaderInterface<::protobuf::MessageToClient>> AddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request)
            {
                return std::unique_ptr<::grpc::ClientReaderInterface<::protobuf::MessageToClient>>(AddPlayerRaw(context, request));
            }
            std::unique_ptr<::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>> AsyncAddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq, void* tag)
            {
                return std::unique_ptr<::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>>(AsyncAddPlayerRaw(context, request, cq, tag));
            }
            std::unique_ptr<::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>> PrepareAsyncAddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>>(PrepareAsyncAddPlayerRaw(context, request, cq));
            }
            // 连接上后等待游戏开始，server会定时通过该服务向所有client发送消息。
            // 游戏过程中玩家执行操作的服务
            virtual ::grpc::Status Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::protobuf::MoveRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>> AsyncMove(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>>(AsyncMoveRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>> PrepareAsyncMove(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>>(PrepareAsyncMoveRaw(context, request, cq));
            }
            virtual ::grpc::Status PickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncPickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncPickPropRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncPickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncPickPropRaw(context, request, cq));
            }
            virtual ::grpc::Status UseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncUseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncUsePropRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncUseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncUsePropRaw(context, request, cq));
            }
            virtual ::grpc::Status ThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncThrowPropRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncThrowPropRaw(context, request, cq));
            }
            virtual ::grpc::Status UseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncUseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncUseSkillRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncUseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncUseSkillRaw(context, request, cq));
            }
            virtual ::grpc::Status SendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncSendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncSendMessageRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncSendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncSendMessageRaw(context, request, cq));
            }
            // rpc GetMessage (IDMsg) returns (stream MsgRes);
            virtual ::grpc::Status StartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncStartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncStartLearningRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncStartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncStartLearningRaw(context, request, cq));
            }
            // 开始修理机器
            virtual ::grpc::Status StartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncStartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncStartRescueMateRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncStartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncStartRescueMateRaw(context, request, cq));
            }
            // 开始救人
            virtual ::grpc::Status StartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncStartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncStartTreatMateRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncStartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncStartTreatMateRaw(context, request, cq));
            }
            // 开始治疗
            virtual ::grpc::Status Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncAttack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncAttackRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncAttack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncAttackRaw(context, request, cq));
            }
            // 攻击
            virtual ::grpc::Status Graduate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncGraduate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncGraduateRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncGraduate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncGraduateRaw(context, request, cq));
            }
            // 相当于逃跑
            virtual ::grpc::Status OpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncOpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncOpenDoorRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncOpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncOpenDoorRaw(context, request, cq));
            }
            // 开门
            virtual ::grpc::Status CloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncCloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncCloseDoorRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncCloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncCloseDoorRaw(context, request, cq));
            }
            // 关门
            virtual ::grpc::Status SkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncSkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncSkipWindowRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncSkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncSkipWindowRaw(context, request, cq));
            }
            // 窗户
            virtual ::grpc::Status StartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncStartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncStartOpenGateRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncStartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncStartOpenGateRaw(context, request, cq));
            }
            // 开闸门
            virtual ::grpc::Status StartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncStartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncStartOpenChestRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncStartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncStartOpenChestRaw(context, request, cq));
            }
            virtual ::grpc::Status EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncEndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncEndAllActionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncEndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncEndAllActionRaw(context, request, cq));
            }
            // 结束所有动作
            class async_interface
            {
            public:
                virtual ~async_interface()
                {
                }
                virtual void TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 游戏开局调用一次的服务
                virtual void AddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg* request, ::grpc::ClientReadReactor<::protobuf::MessageToClient>* reactor) = 0;
                // 连接上后等待游戏开始，server会定时通过该服务向所有client发送消息。
                // 游戏过程中玩家执行操作的服务
                virtual void Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void PickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void PickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void UseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void UseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void ThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void ThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void UseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void UseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void SendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void SendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // rpc GetMessage (IDMsg) returns (stream MsgRes);
                virtual void StartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void StartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 开始修理机器
                virtual void StartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void StartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 开始救人
                virtual void StartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void StartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 开始治疗
                virtual void Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 攻击
                virtual void Graduate(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Graduate(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 相当于逃跑
                virtual void OpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void OpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 开门
                virtual void CloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void CloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 关门
                virtual void SkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void SkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 窗户
                virtual void StartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void StartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 开闸门
                virtual void StartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void StartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 结束所有动作
            };
            typedef class async_interface experimental_async_interface;
            virtual class async_interface* async()
            {
                return nullptr;
            }
            class async_interface* experimental_async()
            {
                return async();
            }

        private:
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncTryConnectionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncTryConnectionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientReaderInterface<::protobuf::MessageToClient>* AddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request) = 0;
            virtual ::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>* AsyncAddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
            virtual ::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>* PrepareAsyncAddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>* AsyncMoveRaw(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>* PrepareAsyncMoveRaw(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncPickPropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncPickPropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncUsePropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncUsePropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncThrowPropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncThrowPropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncUseSkillRaw(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncUseSkillRaw(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncSendMessageRaw(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncSendMessageRaw(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncStartLearningRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncStartLearningRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncStartRescueMateRaw(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncStartRescueMateRaw(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncStartTreatMateRaw(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncStartTreatMateRaw(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncAttackRaw(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncAttackRaw(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncGraduateRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncGraduateRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncOpenDoorRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncOpenDoorRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncCloseDoorRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncCloseDoorRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncSkipWindowRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncSkipWindowRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncStartOpenGateRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncStartOpenGateRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncStartOpenChestRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncStartOpenChestRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncEndAllActionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncEndAllActionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
        };
        class Stub final : public StubInterface
        {
        public:
            Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
            ::grpc::Status TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncTryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncTryConnectionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncTryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncTryConnectionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientReader<::protobuf::MessageToClient>> AddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request)
            {
                return std::unique_ptr<::grpc::ClientReader<::protobuf::MessageToClient>>(AddPlayerRaw(context, request));
            }
            std::unique_ptr<::grpc::ClientAsyncReader<::protobuf::MessageToClient>> AsyncAddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq, void* tag)
            {
                return std::unique_ptr<::grpc::ClientAsyncReader<::protobuf::MessageToClient>>(AsyncAddPlayerRaw(context, request, cq, tag));
            }
            std::unique_ptr<::grpc::ClientAsyncReader<::protobuf::MessageToClient>> PrepareAsyncAddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncReader<::protobuf::MessageToClient>>(PrepareAsyncAddPlayerRaw(context, request, cq));
            }
            ::grpc::Status Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::protobuf::MoveRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>> AsyncMove(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>>(AsyncMoveRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>> PrepareAsyncMove(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>>(PrepareAsyncMoveRaw(context, request, cq));
            }
            ::grpc::Status PickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncPickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncPickPropRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncPickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncPickPropRaw(context, request, cq));
            }
            ::grpc::Status UseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncUseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncUsePropRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncUseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncUsePropRaw(context, request, cq));
            }
            ::grpc::Status ThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncThrowPropRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncThrowPropRaw(context, request, cq));
            }
            ::grpc::Status UseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncUseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncUseSkillRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncUseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncUseSkillRaw(context, request, cq));
            }
            ::grpc::Status SendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncSendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncSendMessageRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncSendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncSendMessageRaw(context, request, cq));
            }
            ::grpc::Status StartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncStartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncStartLearningRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncStartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncStartLearningRaw(context, request, cq));
            }
            ::grpc::Status StartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncStartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncStartRescueMateRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncStartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncStartRescueMateRaw(context, request, cq));
            }
            ::grpc::Status StartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncStartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncStartTreatMateRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncStartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncStartTreatMateRaw(context, request, cq));
            }
            ::grpc::Status Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncAttack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncAttackRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncAttack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncAttackRaw(context, request, cq));
            }
            ::grpc::Status Graduate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncGraduate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncGraduateRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncGraduate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncGraduateRaw(context, request, cq));
            }
            ::grpc::Status OpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncOpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncOpenDoorRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncOpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncOpenDoorRaw(context, request, cq));
            }
            ::grpc::Status CloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncCloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncCloseDoorRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncCloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncCloseDoorRaw(context, request, cq));
            }
            ::grpc::Status SkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncSkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncSkipWindowRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncSkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncSkipWindowRaw(context, request, cq));
            }
            ::grpc::Status StartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncStartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncStartOpenGateRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncStartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncStartOpenGateRaw(context, request, cq));
            }
            ::grpc::Status StartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncStartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncStartOpenChestRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncStartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncStartOpenChestRaw(context, request, cq));
            }
            ::grpc::Status EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncEndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncEndAllActionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncEndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncEndAllActionRaw(context, request, cq));
            }
            class async final :
                public StubInterface::async_interface
            {
            public:
                void TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void AddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg* request, ::grpc::ClientReadReactor<::protobuf::MessageToClient>* reactor) override;
                void Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response, std::function<void(::grpc::Status)>) override;
                void Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void PickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void PickProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void UseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void UseProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void ThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void ThrowProp(::grpc::ClientContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void UseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void UseSkill(::grpc::ClientContext* context, const ::protobuf::SkillMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void SendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void SendMessage(::grpc::ClientContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void StartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void StartLearning(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void StartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void StartRescueMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void StartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void StartTreatMate(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Graduate(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Graduate(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void OpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void OpenDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void CloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void CloseDoor(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void SkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void SkipWindow(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void StartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void StartOpenGate(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void StartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void StartOpenChest(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;

            private:
                friend class Stub;
                explicit async(Stub* stub) :
                    stub_(stub)
                {
                }
                Stub* stub()
                {
                    return stub_;
                }
                Stub* stub_;
            };
            class async* async() override
            {
                return &async_stub_;
            }

        private:
            std::shared_ptr<::grpc::ChannelInterface> channel_;
            class async async_stub_
            {
                this
            };
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncTryConnectionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncTryConnectionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientReader<::protobuf::MessageToClient>* AddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request) override;
            ::grpc::ClientAsyncReader<::protobuf::MessageToClient>* AsyncAddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq, void* tag) override;
            ::grpc::ClientAsyncReader<::protobuf::MessageToClient>* PrepareAsyncAddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>* AsyncMoveRaw(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>* PrepareAsyncMoveRaw(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncPickPropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncPickPropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncUsePropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncUsePropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncThrowPropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncThrowPropRaw(::grpc::ClientContext* context, const ::protobuf::PropMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncUseSkillRaw(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncUseSkillRaw(::grpc::ClientContext* context, const ::protobuf::SkillMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncSendMessageRaw(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncSendMessageRaw(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncStartLearningRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncStartLearningRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncStartRescueMateRaw(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncStartRescueMateRaw(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncStartTreatMateRaw(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncStartTreatMateRaw(::grpc::ClientContext* context, const ::protobuf::TreatAndRescueMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncAttackRaw(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncAttackRaw(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncGraduateRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncGraduateRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncOpenDoorRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncOpenDoorRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncCloseDoorRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncCloseDoorRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncSkipWindowRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncSkipWindowRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncStartOpenGateRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncStartOpenGateRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncStartOpenChestRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncStartOpenChestRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncEndAllActionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncEndAllActionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            const ::grpc::internal::RpcMethod rpcmethod_TryConnection_;
            const ::grpc::internal::RpcMethod rpcmethod_AddPlayer_;
            const ::grpc::internal::RpcMethod rpcmethod_Move_;
            const ::grpc::internal::RpcMethod rpcmethod_PickProp_;
            const ::grpc::internal::RpcMethod rpcmethod_UseProp_;
            const ::grpc::internal::RpcMethod rpcmethod_ThrowProp_;
            const ::grpc::internal::RpcMethod rpcmethod_UseSkill_;
            const ::grpc::internal::RpcMethod rpcmethod_SendMessage_;
            const ::grpc::internal::RpcMethod rpcmethod_StartLearning_;
            const ::grpc::internal::RpcMethod rpcmethod_StartRescueMate_;
            const ::grpc::internal::RpcMethod rpcmethod_StartTreatMate_;
            const ::grpc::internal::RpcMethod rpcmethod_Attack_;
            const ::grpc::internal::RpcMethod rpcmethod_Graduate_;
            const ::grpc::internal::RpcMethod rpcmethod_OpenDoor_;
            const ::grpc::internal::RpcMethod rpcmethod_CloseDoor_;
            const ::grpc::internal::RpcMethod rpcmethod_SkipWindow_;
            const ::grpc::internal::RpcMethod rpcmethod_StartOpenGate_;
            const ::grpc::internal::RpcMethod rpcmethod_StartOpenChest_;
            const ::grpc::internal::RpcMethod rpcmethod_EndAllAction_;
        };
        static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

        class Service : public ::grpc::Service
        {
        public:
            Service();
            virtual ~Service();
            virtual ::grpc::Status TryConnection(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 游戏开局调用一次的服务
            virtual ::grpc::Status AddPlayer(::grpc::ServerContext* context, const ::protobuf::PlayerMsg* request, ::grpc::ServerWriter<::protobuf::MessageToClient>* writer);
            // 连接上后等待游戏开始，server会定时通过该服务向所有client发送消息。
            // 游戏过程中玩家执行操作的服务
            virtual ::grpc::Status Move(::grpc::ServerContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response);
            virtual ::grpc::Status PickProp(::grpc::ServerContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response);
            virtual ::grpc::Status UseProp(::grpc::ServerContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response);
            virtual ::grpc::Status ThrowProp(::grpc::ServerContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response);
            virtual ::grpc::Status UseSkill(::grpc::ServerContext* context, const ::protobuf::SkillMsg* request, ::protobuf::BoolRes* response);
            virtual ::grpc::Status SendMessage(::grpc::ServerContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response);
            // rpc GetMessage (IDMsg) returns (stream MsgRes);
            virtual ::grpc::Status StartLearning(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 开始修理机器
            virtual ::grpc::Status StartRescueMate(::grpc::ServerContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response);
            // 开始救人
            virtual ::grpc::Status StartTreatMate(::grpc::ServerContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response);
            // 开始治疗
            virtual ::grpc::Status Attack(::grpc::ServerContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response);
            // 攻击
            virtual ::grpc::Status Graduate(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 相当于逃跑
            virtual ::grpc::Status OpenDoor(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 开门
            virtual ::grpc::Status CloseDoor(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 关门
            virtual ::grpc::Status SkipWindow(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 窗户
            virtual ::grpc::Status StartOpenGate(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 开闸门
            virtual ::grpc::Status StartOpenChest(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            virtual ::grpc::Status EndAllAction(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 结束所有动作
        };
        template<class BaseClass>
        class WithAsyncMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodAsync(0);
            }
            ~WithAsyncMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestTryConnection(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodAsync(1);
            }
            ~WithAsyncMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestAddPlayer(::grpc::ServerContext* context, ::protobuf::PlayerMsg* request, ::grpc::ServerAsyncWriter<::protobuf::MessageToClient>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Move()
            {
                ::grpc::Service::MarkMethodAsync(2);
            }
            ~WithAsyncMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestMove(::grpc::ServerContext* context, ::protobuf::MoveMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::MoveRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_PickProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_PickProp()
            {
                ::grpc::Service::MarkMethodAsync(3);
            }
            ~WithAsyncMethod_PickProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status PickProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestPickProp(::grpc::ServerContext* context, ::protobuf::PropMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_UseProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_UseProp()
            {
                ::grpc::Service::MarkMethodAsync(4);
            }
            ~WithAsyncMethod_UseProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestUseProp(::grpc::ServerContext* context, ::protobuf::PropMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_ThrowProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_ThrowProp()
            {
                ::grpc::Service::MarkMethodAsync(5);
            }
            ~WithAsyncMethod_ThrowProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status ThrowProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestThrowProp(::grpc::ServerContext* context, ::protobuf::PropMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_UseSkill : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_UseSkill()
            {
                ::grpc::Service::MarkMethodAsync(6);
            }
            ~WithAsyncMethod_UseSkill() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseSkill(::grpc::ServerContext* /*context*/, const ::protobuf::SkillMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestUseSkill(::grpc::ServerContext* context, ::protobuf::SkillMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_SendMessage : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_SendMessage()
            {
                ::grpc::Service::MarkMethodAsync(7);
            }
            ~WithAsyncMethod_SendMessage() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SendMessage(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestSendMessage(::grpc::ServerContext* context, ::protobuf::SendMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_StartLearning : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_StartLearning()
            {
                ::grpc::Service::MarkMethodAsync(8);
            }
            ~WithAsyncMethod_StartLearning() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartLearning(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartLearning(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_StartRescueMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_StartRescueMate()
            {
                ::grpc::Service::MarkMethodAsync(9);
            }
            ~WithAsyncMethod_StartRescueMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartRescueMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartRescueMate(::grpc::ServerContext* context, ::protobuf::TreatAndRescueMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_StartTreatMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_StartTreatMate()
            {
                ::grpc::Service::MarkMethodAsync(10);
            }
            ~WithAsyncMethod_StartTreatMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartTreatMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartTreatMate(::grpc::ServerContext* context, ::protobuf::TreatAndRescueMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Attack()
            {
                ::grpc::Service::MarkMethodAsync(11);
            }
            ~WithAsyncMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestAttack(::grpc::ServerContext* context, ::protobuf::AttackMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Graduate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Graduate()
            {
                ::grpc::Service::MarkMethodAsync(12);
            }
            ~WithAsyncMethod_Graduate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Graduate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestGraduate(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_OpenDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_OpenDoor()
            {
                ::grpc::Service::MarkMethodAsync(13);
            }
            ~WithAsyncMethod_OpenDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status OpenDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestOpenDoor(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_CloseDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_CloseDoor()
            {
                ::grpc::Service::MarkMethodAsync(14);
            }
            ~WithAsyncMethod_CloseDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status CloseDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestCloseDoor(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_SkipWindow : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_SkipWindow()
            {
                ::grpc::Service::MarkMethodAsync(15);
            }
            ~WithAsyncMethod_SkipWindow() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SkipWindow(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestSkipWindow(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_StartOpenGate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_StartOpenGate()
            {
                ::grpc::Service::MarkMethodAsync(16);
            }
            ~WithAsyncMethod_StartOpenGate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenGate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartOpenGate(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_StartOpenChest : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_StartOpenChest()
            {
                ::grpc::Service::MarkMethodAsync(17);
            }
            ~WithAsyncMethod_StartOpenChest() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenChest(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartOpenChest(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodAsync(18);
            }
            ~WithAsyncMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestEndAllAction(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        typedef WithAsyncMethod_TryConnection<WithAsyncMethod_AddPlayer<WithAsyncMethod_Move<WithAsyncMethod_PickProp<WithAsyncMethod_UseProp<WithAsyncMethod_ThrowProp<WithAsyncMethod_UseSkill<WithAsyncMethod_SendMessage<WithAsyncMethod_StartLearning<WithAsyncMethod_StartRescueMate<WithAsyncMethod_StartTreatMate<WithAsyncMethod_Attack<WithAsyncMethod_Graduate<WithAsyncMethod_OpenDoor<WithAsyncMethod_CloseDoor<WithAsyncMethod_SkipWindow<WithAsyncMethod_StartOpenGate<WithAsyncMethod_StartOpenChest<WithAsyncMethod_EndAllAction<Service>>>>>>>>>>>>>>>>>>> AsyncService;
        template<class BaseClass>
        class WithCallbackMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodCallback(0, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                          { return this->TryConnection(context, request, response); }));
            }
            void SetMessageAllocatorFor_TryConnection(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* TryConnection(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodCallback(1, new ::grpc::internal::CallbackServerStreamingHandler<::protobuf::PlayerMsg, ::protobuf::MessageToClient>([this](::grpc::CallbackServerContext* context, const ::protobuf::PlayerMsg* request)
                                                                                                                                                                { return this->AddPlayer(context, request); }));
            }
            ~WithCallbackMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerWriteReactor<::protobuf::MessageToClient>* AddPlayer(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Move()
            {
                ::grpc::Service::MarkMethodCallback(2, new ::grpc::internal::CallbackUnaryHandler<::protobuf::MoveMsg, ::protobuf::MoveRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response)
                                                                                                                                            { return this->Move(context, request, response); }));
            }
            void SetMessageAllocatorFor_Move(
                ::grpc::MessageAllocator<::protobuf::MoveMsg, ::protobuf::MoveRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::MoveMsg, ::protobuf::MoveRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Move(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_PickProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_PickProp()
            {
                ::grpc::Service::MarkMethodCallback(3, new ::grpc::internal::CallbackUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                            { return this->PickProp(context, request, response); }));
            }
            void SetMessageAllocatorFor_PickProp(
                ::grpc::MessageAllocator<::protobuf::PropMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_PickProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status PickProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* PickProp(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_UseProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_UseProp()
            {
                ::grpc::Service::MarkMethodCallback(4, new ::grpc::internal::CallbackUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                            { return this->UseProp(context, request, response); }));
            }
            void SetMessageAllocatorFor_UseProp(
                ::grpc::MessageAllocator<::protobuf::PropMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_UseProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* UseProp(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_ThrowProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_ThrowProp()
            {
                ::grpc::Service::MarkMethodCallback(5, new ::grpc::internal::CallbackUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::PropMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                            { return this->ThrowProp(context, request, response); }));
            }
            void SetMessageAllocatorFor_ThrowProp(
                ::grpc::MessageAllocator<::protobuf::PropMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_ThrowProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status ThrowProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* ThrowProp(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_UseSkill : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_UseSkill()
            {
                ::grpc::Service::MarkMethodCallback(6, new ::grpc::internal::CallbackUnaryHandler<::protobuf::SkillMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::SkillMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                             { return this->UseSkill(context, request, response); }));
            }
            void SetMessageAllocatorFor_UseSkill(
                ::grpc::MessageAllocator<::protobuf::SkillMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::SkillMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_UseSkill() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseSkill(::grpc::ServerContext* /*context*/, const ::protobuf::SkillMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* UseSkill(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::SkillMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_SendMessage : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_SendMessage()
            {
                ::grpc::Service::MarkMethodCallback(7, new ::grpc::internal::CallbackUnaryHandler<::protobuf::SendMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                            { return this->SendMessage(context, request, response); }));
            }
            void SetMessageAllocatorFor_SendMessage(
                ::grpc::MessageAllocator<::protobuf::SendMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::SendMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_SendMessage() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SendMessage(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* SendMessage(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_StartLearning : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_StartLearning()
            {
                ::grpc::Service::MarkMethodCallback(8, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                          { return this->StartLearning(context, request, response); }));
            }
            void SetMessageAllocatorFor_StartLearning(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_StartLearning() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartLearning(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartLearning(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_StartRescueMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_StartRescueMate()
            {
                ::grpc::Service::MarkMethodCallback(9, new ::grpc::internal::CallbackUnaryHandler<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                                      { return this->StartRescueMate(context, request, response); }));
            }
            void SetMessageAllocatorFor_StartRescueMate(
                ::grpc::MessageAllocator<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_StartRescueMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartRescueMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartRescueMate(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_StartTreatMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_StartTreatMate()
            {
                ::grpc::Service::MarkMethodCallback(10, new ::grpc::internal::CallbackUnaryHandler<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::TreatAndRescueMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                                       { return this->StartTreatMate(context, request, response); }));
            }
            void SetMessageAllocatorFor_StartTreatMate(
                ::grpc::MessageAllocator<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_StartTreatMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartTreatMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartTreatMate(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Attack()
            {
                ::grpc::Service::MarkMethodCallback(11, new ::grpc::internal::CallbackUnaryHandler<::protobuf::AttackMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                               { return this->Attack(context, request, response); }));
            }
            void SetMessageAllocatorFor_Attack(
                ::grpc::MessageAllocator<::protobuf::AttackMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::AttackMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Attack(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Graduate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Graduate()
            {
                ::grpc::Service::MarkMethodCallback(12, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->Graduate(context, request, response); }));
            }
            void SetMessageAllocatorFor_Graduate(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Graduate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Graduate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Graduate(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_OpenDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_OpenDoor()
            {
                ::grpc::Service::MarkMethodCallback(13, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->OpenDoor(context, request, response); }));
            }
            void SetMessageAllocatorFor_OpenDoor(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_OpenDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status OpenDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* OpenDoor(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_CloseDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_CloseDoor()
            {
                ::grpc::Service::MarkMethodCallback(14, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->CloseDoor(context, request, response); }));
            }
            void SetMessageAllocatorFor_CloseDoor(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_CloseDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status CloseDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* CloseDoor(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_SkipWindow : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_SkipWindow()
            {
                ::grpc::Service::MarkMethodCallback(15, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->SkipWindow(context, request, response); }));
            }
            void SetMessageAllocatorFor_SkipWindow(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_SkipWindow() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SkipWindow(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* SkipWindow(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_StartOpenGate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_StartOpenGate()
            {
                ::grpc::Service::MarkMethodCallback(16, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->StartOpenGate(context, request, response); }));
            }
            void SetMessageAllocatorFor_StartOpenGate(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_StartOpenGate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenGate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartOpenGate(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_StartOpenChest : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_StartOpenChest()
            {
                ::grpc::Service::MarkMethodCallback(17, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->StartOpenChest(context, request, response); }));
            }
            void SetMessageAllocatorFor_StartOpenChest(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_StartOpenChest() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenChest(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartOpenChest(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodCallback(18, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->EndAllAction(context, request, response); }));
            }
            void SetMessageAllocatorFor_EndAllAction(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* EndAllAction(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        typedef WithCallbackMethod_TryConnection<WithCallbackMethod_AddPlayer<WithCallbackMethod_Move<WithCallbackMethod_PickProp<WithCallbackMethod_UseProp<WithCallbackMethod_ThrowProp<WithCallbackMethod_UseSkill<WithCallbackMethod_SendMessage<WithCallbackMethod_StartLearning<WithCallbackMethod_StartRescueMate<WithCallbackMethod_StartTreatMate<WithCallbackMethod_Attack<WithCallbackMethod_Graduate<WithCallbackMethod_OpenDoor<WithCallbackMethod_CloseDoor<WithCallbackMethod_SkipWindow<WithCallbackMethod_StartOpenGate<WithCallbackMethod_StartOpenChest<WithCallbackMethod_EndAllAction<Service>>>>>>>>>>>>>>>>>>> CallbackService;
        typedef CallbackService ExperimentalCallbackService;
        template<class BaseClass>
        class WithGenericMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodGeneric(0);
            }
            ~WithGenericMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodGeneric(1);
            }
            ~WithGenericMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Move()
            {
                ::grpc::Service::MarkMethodGeneric(2);
            }
            ~WithGenericMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_PickProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_PickProp()
            {
                ::grpc::Service::MarkMethodGeneric(3);
            }
            ~WithGenericMethod_PickProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status PickProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_UseProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_UseProp()
            {
                ::grpc::Service::MarkMethodGeneric(4);
            }
            ~WithGenericMethod_UseProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_ThrowProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_ThrowProp()
            {
                ::grpc::Service::MarkMethodGeneric(5);
            }
            ~WithGenericMethod_ThrowProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status ThrowProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_UseSkill : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_UseSkill()
            {
                ::grpc::Service::MarkMethodGeneric(6);
            }
            ~WithGenericMethod_UseSkill() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseSkill(::grpc::ServerContext* /*context*/, const ::protobuf::SkillMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_SendMessage : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_SendMessage()
            {
                ::grpc::Service::MarkMethodGeneric(7);
            }
            ~WithGenericMethod_SendMessage() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SendMessage(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_StartLearning : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_StartLearning()
            {
                ::grpc::Service::MarkMethodGeneric(8);
            }
            ~WithGenericMethod_StartLearning() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartLearning(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_StartRescueMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_StartRescueMate()
            {
                ::grpc::Service::MarkMethodGeneric(9);
            }
            ~WithGenericMethod_StartRescueMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartRescueMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_StartTreatMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_StartTreatMate()
            {
                ::grpc::Service::MarkMethodGeneric(10);
            }
            ~WithGenericMethod_StartTreatMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartTreatMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Attack()
            {
                ::grpc::Service::MarkMethodGeneric(11);
            }
            ~WithGenericMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Graduate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Graduate()
            {
                ::grpc::Service::MarkMethodGeneric(12);
            }
            ~WithGenericMethod_Graduate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Graduate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_OpenDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_OpenDoor()
            {
                ::grpc::Service::MarkMethodGeneric(13);
            }
            ~WithGenericMethod_OpenDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status OpenDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_CloseDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_CloseDoor()
            {
                ::grpc::Service::MarkMethodGeneric(14);
            }
            ~WithGenericMethod_CloseDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status CloseDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_SkipWindow : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_SkipWindow()
            {
                ::grpc::Service::MarkMethodGeneric(15);
            }
            ~WithGenericMethod_SkipWindow() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SkipWindow(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_StartOpenGate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_StartOpenGate()
            {
                ::grpc::Service::MarkMethodGeneric(16);
            }
            ~WithGenericMethod_StartOpenGate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenGate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_StartOpenChest : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_StartOpenChest()
            {
                ::grpc::Service::MarkMethodGeneric(17);
            }
            ~WithGenericMethod_StartOpenChest() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenChest(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodGeneric(18);
            }
            ~WithGenericMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithRawMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodRaw(0);
            }
            ~WithRawMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestTryConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodRaw(1);
            }
            ~WithRawMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestAddPlayer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter<::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Move()
            {
                ::grpc::Service::MarkMethodRaw(2);
            }
            ~WithRawMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestMove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_PickProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_PickProp()
            {
                ::grpc::Service::MarkMethodRaw(3);
            }
            ~WithRawMethod_PickProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status PickProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestPickProp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_UseProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_UseProp()
            {
                ::grpc::Service::MarkMethodRaw(4);
            }
            ~WithRawMethod_UseProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestUseProp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_ThrowProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_ThrowProp()
            {
                ::grpc::Service::MarkMethodRaw(5);
            }
            ~WithRawMethod_ThrowProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status ThrowProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestThrowProp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_UseSkill : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_UseSkill()
            {
                ::grpc::Service::MarkMethodRaw(6);
            }
            ~WithRawMethod_UseSkill() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseSkill(::grpc::ServerContext* /*context*/, const ::protobuf::SkillMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestUseSkill(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_SendMessage : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_SendMessage()
            {
                ::grpc::Service::MarkMethodRaw(7);
            }
            ~WithRawMethod_SendMessage() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SendMessage(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestSendMessage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_StartLearning : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_StartLearning()
            {
                ::grpc::Service::MarkMethodRaw(8);
            }
            ~WithRawMethod_StartLearning() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartLearning(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartLearning(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_StartRescueMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_StartRescueMate()
            {
                ::grpc::Service::MarkMethodRaw(9);
            }
            ~WithRawMethod_StartRescueMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartRescueMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartRescueMate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_StartTreatMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_StartTreatMate()
            {
                ::grpc::Service::MarkMethodRaw(10);
            }
            ~WithRawMethod_StartTreatMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartTreatMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartTreatMate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Attack()
            {
                ::grpc::Service::MarkMethodRaw(11);
            }
            ~WithRawMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestAttack(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Graduate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Graduate()
            {
                ::grpc::Service::MarkMethodRaw(12);
            }
            ~WithRawMethod_Graduate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Graduate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestGraduate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_OpenDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_OpenDoor()
            {
                ::grpc::Service::MarkMethodRaw(13);
            }
            ~WithRawMethod_OpenDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status OpenDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestOpenDoor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_CloseDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_CloseDoor()
            {
                ::grpc::Service::MarkMethodRaw(14);
            }
            ~WithRawMethod_CloseDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status CloseDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestCloseDoor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_SkipWindow : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_SkipWindow()
            {
                ::grpc::Service::MarkMethodRaw(15);
            }
            ~WithRawMethod_SkipWindow() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SkipWindow(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestSkipWindow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_StartOpenGate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_StartOpenGate()
            {
                ::grpc::Service::MarkMethodRaw(16);
            }
            ~WithRawMethod_StartOpenGate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenGate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartOpenGate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_StartOpenChest : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_StartOpenChest()
            {
                ::grpc::Service::MarkMethodRaw(17);
            }
            ~WithRawMethod_StartOpenChest() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenChest(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestStartOpenChest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodRaw(18);
            }
            ~WithRawMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestEndAllAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodRawCallback(0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->TryConnection(context, request, response); }));
            }
            ~WithRawCallbackMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* TryConnection(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodRawCallback(1, new ::grpc::internal::CallbackServerStreamingHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request)
                                                                                                                                                       { return this->AddPlayer(context, request); }));
            }
            ~WithRawCallbackMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerWriteReactor<::grpc::ByteBuffer>* AddPlayer(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Move()
            {
                ::grpc::Service::MarkMethodRawCallback(2, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->Move(context, request, response); }));
            }
            ~WithRawCallbackMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Move(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_PickProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_PickProp()
            {
                ::grpc::Service::MarkMethodRawCallback(3, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->PickProp(context, request, response); }));
            }
            ~WithRawCallbackMethod_PickProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status PickProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* PickProp(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_UseProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_UseProp()
            {
                ::grpc::Service::MarkMethodRawCallback(4, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->UseProp(context, request, response); }));
            }
            ~WithRawCallbackMethod_UseProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* UseProp(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_ThrowProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_ThrowProp()
            {
                ::grpc::Service::MarkMethodRawCallback(5, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->ThrowProp(context, request, response); }));
            }
            ~WithRawCallbackMethod_ThrowProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status ThrowProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* ThrowProp(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_UseSkill : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_UseSkill()
            {
                ::grpc::Service::MarkMethodRawCallback(6, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->UseSkill(context, request, response); }));
            }
            ~WithRawCallbackMethod_UseSkill() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status UseSkill(::grpc::ServerContext* /*context*/, const ::protobuf::SkillMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* UseSkill(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_SendMessage : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_SendMessage()
            {
                ::grpc::Service::MarkMethodRawCallback(7, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->SendMessage(context, request, response); }));
            }
            ~WithRawCallbackMethod_SendMessage() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SendMessage(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* SendMessage(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_StartLearning : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_StartLearning()
            {
                ::grpc::Service::MarkMethodRawCallback(8, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->StartLearning(context, request, response); }));
            }
            ~WithRawCallbackMethod_StartLearning() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartLearning(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartLearning(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_StartRescueMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_StartRescueMate()
            {
                ::grpc::Service::MarkMethodRawCallback(9, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->StartRescueMate(context, request, response); }));
            }
            ~WithRawCallbackMethod_StartRescueMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartRescueMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartRescueMate(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_StartTreatMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_StartTreatMate()
            {
                ::grpc::Service::MarkMethodRawCallback(10, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->StartTreatMate(context, request, response); }));
            }
            ~WithRawCallbackMethod_StartTreatMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartTreatMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartTreatMate(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Attack()
            {
                ::grpc::Service::MarkMethodRawCallback(11, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->Attack(context, request, response); }));
            }
            ~WithRawCallbackMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Attack(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Graduate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Graduate()
            {
                ::grpc::Service::MarkMethodRawCallback(12, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->Graduate(context, request, response); }));
            }
            ~WithRawCallbackMethod_Graduate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Graduate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Graduate(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_OpenDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_OpenDoor()
            {
                ::grpc::Service::MarkMethodRawCallback(13, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->OpenDoor(context, request, response); }));
            }
            ~WithRawCallbackMethod_OpenDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status OpenDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* OpenDoor(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_CloseDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_CloseDoor()
            {
                ::grpc::Service::MarkMethodRawCallback(14, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->CloseDoor(context, request, response); }));
            }
            ~WithRawCallbackMethod_CloseDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status CloseDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* CloseDoor(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_SkipWindow : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_SkipWindow()
            {
                ::grpc::Service::MarkMethodRawCallback(15, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->SkipWindow(context, request, response); }));
            }
            ~WithRawCallbackMethod_SkipWindow() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status SkipWindow(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* SkipWindow(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_StartOpenGate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_StartOpenGate()
            {
                ::grpc::Service::MarkMethodRawCallback(16, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->StartOpenGate(context, request, response); }));
            }
            ~WithRawCallbackMethod_StartOpenGate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenGate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartOpenGate(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_StartOpenChest : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_StartOpenChest()
            {
                ::grpc::Service::MarkMethodRawCallback(17, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->StartOpenChest(context, request, response); }));
            }
            ~WithRawCallbackMethod_StartOpenChest() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status StartOpenChest(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* StartOpenChest(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodRawCallback(18, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->EndAllAction(context, request, response); }));
            }
            ~WithRawCallbackMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* EndAllAction(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodStreamed(0, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                          { return this->StreamedTryConnection(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedTryConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Move()
            {
                ::grpc::Service::MarkMethodStreamed(2, new ::grpc::internal::StreamedUnaryHandler<::protobuf::MoveMsg, ::protobuf::MoveRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::MoveMsg, ::protobuf::MoveRes>* streamer)
                                                                                                                                            { return this->StreamedMove(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedMove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::MoveMsg, ::protobuf::MoveRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_PickProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_PickProp()
            {
                ::grpc::Service::MarkMethodStreamed(3, new ::grpc::internal::StreamedUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::PropMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                            { return this->StreamedPickProp(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_PickProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status PickProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedPickProp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::PropMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_UseProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_UseProp()
            {
                ::grpc::Service::MarkMethodStreamed(4, new ::grpc::internal::StreamedUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::PropMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                            { return this->StreamedUseProp(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_UseProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status UseProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedUseProp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::PropMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_ThrowProp : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_ThrowProp()
            {
                ::grpc::Service::MarkMethodStreamed(5, new ::grpc::internal::StreamedUnaryHandler<::protobuf::PropMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::PropMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                            { return this->StreamedThrowProp(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_ThrowProp() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status ThrowProp(::grpc::ServerContext* /*context*/, const ::protobuf::PropMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedThrowProp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::PropMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_UseSkill : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_UseSkill()
            {
                ::grpc::Service::MarkMethodStreamed(6, new ::grpc::internal::StreamedUnaryHandler<::protobuf::SkillMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::SkillMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                             { return this->StreamedUseSkill(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_UseSkill() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status UseSkill(::grpc::ServerContext* /*context*/, const ::protobuf::SkillMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedUseSkill(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::SkillMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_SendMessage : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_SendMessage()
            {
                ::grpc::Service::MarkMethodStreamed(7, new ::grpc::internal::StreamedUnaryHandler<::protobuf::SendMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::SendMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                            { return this->StreamedSendMessage(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_SendMessage() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status SendMessage(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedSendMessage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::SendMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_StartLearning : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_StartLearning()
            {
                ::grpc::Service::MarkMethodStreamed(8, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                          { return this->StreamedStartLearning(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_StartLearning() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status StartLearning(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedStartLearning(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_StartRescueMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_StartRescueMate()
            {
                ::grpc::Service::MarkMethodStreamed(9, new ::grpc::internal::StreamedUnaryHandler<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                                      { return this->StreamedStartRescueMate(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_StartRescueMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status StartRescueMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedStartRescueMate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_StartTreatMate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_StartTreatMate()
            {
                ::grpc::Service::MarkMethodStreamed(10, new ::grpc::internal::StreamedUnaryHandler<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                                       { return this->StreamedStartTreatMate(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_StartTreatMate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status StartTreatMate(::grpc::ServerContext* /*context*/, const ::protobuf::TreatAndRescueMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedStartTreatMate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::TreatAndRescueMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Attack()
            {
                ::grpc::Service::MarkMethodStreamed(11, new ::grpc::internal::StreamedUnaryHandler<::protobuf::AttackMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::AttackMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                               { return this->StreamedAttack(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedAttack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::AttackMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Graduate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Graduate()
            {
                ::grpc::Service::MarkMethodStreamed(12, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedGraduate(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Graduate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Graduate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedGraduate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_OpenDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_OpenDoor()
            {
                ::grpc::Service::MarkMethodStreamed(13, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedOpenDoor(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_OpenDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status OpenDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedOpenDoor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_CloseDoor : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_CloseDoor()
            {
                ::grpc::Service::MarkMethodStreamed(14, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedCloseDoor(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_CloseDoor() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status CloseDoor(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedCloseDoor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_SkipWindow : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_SkipWindow()
            {
                ::grpc::Service::MarkMethodStreamed(15, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedSkipWindow(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_SkipWindow() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status SkipWindow(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedSkipWindow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_StartOpenGate : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_StartOpenGate()
            {
                ::grpc::Service::MarkMethodStreamed(16, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedStartOpenGate(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_StartOpenGate() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status StartOpenGate(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedStartOpenGate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_StartOpenChest : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_StartOpenChest()
            {
                ::grpc::Service::MarkMethodStreamed(17, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedStartOpenChest(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_StartOpenChest() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status StartOpenChest(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedStartOpenChest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodStreamed(18, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedEndAllAction(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedEndAllAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        typedef WithStreamedUnaryMethod_TryConnection<WithStreamedUnaryMethod_Move<WithStreamedUnaryMethod_PickProp<WithStreamedUnaryMethod_UseProp<WithStreamedUnaryMethod_ThrowProp<WithStreamedUnaryMethod_UseSkill<WithStreamedUnaryMethod_SendMessage<WithStreamedUnaryMethod_StartLearning<WithStreamedUnaryMethod_StartRescueMate<WithStreamedUnaryMethod_StartTreatMate<WithStreamedUnaryMethod_Attack<WithStreamedUnaryMethod_Graduate<WithStreamedUnaryMethod_OpenDoor<WithStreamedUnaryMethod_CloseDoor<WithStreamedUnaryMethod_SkipWindow<WithStreamedUnaryMethod_StartOpenGate<WithStreamedUnaryMethod_StartOpenChest<WithStreamedUnaryMethod_EndAllAction<Service>>>>>>>>>>>>>>>>>> StreamedUnaryService;
        template<class BaseClass>
        class WithSplitStreamingMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithSplitStreamingMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodStreamed(1, new ::grpc::internal::SplitServerStreamingHandler<::protobuf::PlayerMsg, ::protobuf::MessageToClient>([this](::grpc::ServerContext* context, ::grpc::ServerSplitStreamer<::protobuf::PlayerMsg, ::protobuf::MessageToClient>* streamer)
                                                                                                                                                             { return this->StreamedAddPlayer(context, streamer); }));
            }
            ~WithSplitStreamingMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with split streamed
            virtual ::grpc::Status StreamedAddPlayer(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer<::protobuf::PlayerMsg, ::protobuf::MessageToClient>* server_split_streamer) = 0;
        };
        typedef WithSplitStreamingMethod_AddPlayer<Service> SplitStreamedService;
        typedef WithStreamedUnaryMethod_TryConnection<WithSplitStreamingMethod_AddPlayer<WithStreamedUnaryMethod_Move<WithStreamedUnaryMethod_PickProp<WithStreamedUnaryMethod_UseProp<WithStreamedUnaryMethod_ThrowProp<WithStreamedUnaryMethod_UseSkill<WithStreamedUnaryMethod_SendMessage<WithStreamedUnaryMethod_StartLearning<WithStreamedUnaryMethod_StartRescueMate<WithStreamedUnaryMethod_StartTreatMate<WithStreamedUnaryMethod_Attack<WithStreamedUnaryMethod_Graduate<WithStreamedUnaryMethod_OpenDoor<WithStreamedUnaryMethod_CloseDoor<WithStreamedUnaryMethod_SkipWindow<WithStreamedUnaryMethod_StartOpenGate<WithStreamedUnaryMethod_StartOpenChest<WithStreamedUnaryMethod_EndAllAction<Service>>>>>>>>>>>>>>>>>>> StreamedService;
    };

}  // namespace protobuf

#endif  // GRPC_Services_2eproto__INCLUDED
