// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageType.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>   // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MessageType_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal
{
    class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MessageType_2eproto
{
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
    static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MessageType_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace protobuf
{

    enum PlaceType : int
    {
        NULL_PLACE_TYPE = 0,
        LAND = 1,
        WALL = 2,
        GRASS = 3,
        MACHINE = 4,
        GATE = 5,
        HIDDEN_GATE = 6,
        PlaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        PlaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool PlaceType_IsValid(int value);
    constexpr PlaceType PlaceType_MIN = NULL_PLACE_TYPE;
    constexpr PlaceType PlaceType_MAX = HIDDEN_GATE;
    constexpr int PlaceType_ARRAYSIZE = PlaceType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceType_descriptor();
    template<typename T>
    inline const std::string& PlaceType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PlaceType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PlaceType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            PlaceType_descriptor(), enum_t_value
        );
    }
    inline bool PlaceType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceType>(
            PlaceType_descriptor(), name, value
        );
    }
    enum ShapeType : int
    {
        NULL_SHAPE_TYPE = 0,
        CIRCLE = 1,
        SQUARE = 2,
        ShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        ShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool ShapeType_IsValid(int value);
    constexpr ShapeType ShapeType_MIN = NULL_SHAPE_TYPE;
    constexpr ShapeType ShapeType_MAX = SQUARE;
    constexpr int ShapeType_ARRAYSIZE = ShapeType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeType_descriptor();
    template<typename T>
    inline const std::string& ShapeType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ShapeType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ShapeType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            ShapeType_descriptor(), enum_t_value
        );
    }
    inline bool ShapeType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShapeType>(
            ShapeType_descriptor(), name, value
        );
    }
    enum PropType : int
    {
        NULL_PROP_TYPE = 0,
        PTYPE1 = 1,
        PTYPE2 = 2,
        PTYPE3 = 3,
        PTYPE4 = 4,
        PropType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        PropType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool PropType_IsValid(int value);
    constexpr PropType PropType_MIN = NULL_PROP_TYPE;
    constexpr PropType PropType_MAX = PTYPE4;
    constexpr int PropType_ARRAYSIZE = PropType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PropType_descriptor();
    template<typename T>
    inline const std::string& PropType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PropType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PropType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            PropType_descriptor(), enum_t_value
        );
    }
    inline bool PropType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PropType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PropType>(
            PropType_descriptor(), name, value
        );
    }
    enum HumanBuffType : int
    {
        NULL_HBUFF_TYPE = 0,
        HBUFFTYPE1 = 1,
        HBUFFTYPE2 = 2,
        HBUFFTYPE3 = 3,
        HBUFFTYPE4 = 4,
        HumanBuffType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        HumanBuffType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool HumanBuffType_IsValid(int value);
    constexpr HumanBuffType HumanBuffType_MIN = NULL_HBUFF_TYPE;
    constexpr HumanBuffType HumanBuffType_MAX = HBUFFTYPE4;
    constexpr int HumanBuffType_ARRAYSIZE = HumanBuffType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HumanBuffType_descriptor();
    template<typename T>
    inline const std::string& HumanBuffType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, HumanBuffType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function HumanBuffType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            HumanBuffType_descriptor(), enum_t_value
        );
    }
    inline bool HumanBuffType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HumanBuffType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HumanBuffType>(
            HumanBuffType_descriptor(), name, value
        );
    }
    enum ButcherBuffType : int
    {
        NULL_BBUFF_TYPE = 0,
        BBUFFTYPE1 = 1,
        BBUFFTYPE2 = 2,
        BBUFFTYPE3 = 3,
        BBUFFTYPE4 = 4,
        ButcherBuffType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        ButcherBuffType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool ButcherBuffType_IsValid(int value);
    constexpr ButcherBuffType ButcherBuffType_MIN = NULL_BBUFF_TYPE;
    constexpr ButcherBuffType ButcherBuffType_MAX = BBUFFTYPE4;
    constexpr int ButcherBuffType_ARRAYSIZE = ButcherBuffType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ButcherBuffType_descriptor();
    template<typename T>
    inline const std::string& ButcherBuffType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ButcherBuffType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ButcherBuffType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            ButcherBuffType_descriptor(), enum_t_value
        );
    }
    inline bool ButcherBuffType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ButcherBuffType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ButcherBuffType>(
            ButcherBuffType_descriptor(), name, value
        );
    }
    enum PlayerType : int
    {
        NULL_PLAYER_TYPE = 0,
        HUMAN_PLAYER = 1,
        BUTCHER_PLAYER = 2,
        PlayerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        PlayerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool PlayerType_IsValid(int value);
    constexpr PlayerType PlayerType_MIN = NULL_PLAYER_TYPE;
    constexpr PlayerType PlayerType_MAX = BUTCHER_PLAYER;
    constexpr int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerType_descriptor();
    template<typename T>
    inline const std::string& PlayerType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PlayerType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PlayerType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            PlayerType_descriptor(), enum_t_value
        );
    }
    inline bool PlayerType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerType>(
            PlayerType_descriptor(), name, value
        );
    }
    enum HumanType : int
    {
        NULL_HUMAN_TYPE = 0,
        HUMANTYPE1 = 1,
        HUMANTYPE2 = 2,
        HUMANTYPE3 = 3,
        HUMANTYPE4 = 4,
        HumanType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        HumanType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool HumanType_IsValid(int value);
    constexpr HumanType HumanType_MIN = NULL_HUMAN_TYPE;
    constexpr HumanType HumanType_MAX = HUMANTYPE4;
    constexpr int HumanType_ARRAYSIZE = HumanType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HumanType_descriptor();
    template<typename T>
    inline const std::string& HumanType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, HumanType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function HumanType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            HumanType_descriptor(), enum_t_value
        );
    }
    inline bool HumanType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HumanType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HumanType>(
            HumanType_descriptor(), name, value
        );
    }
    enum ButcherType : int
    {
        NULL_BUTCHER_TYPE = 0,
        BUTCHERTYPE1 = 1,
        BUTCHERTYPE2 = 2,
        BUTCHERTYPE3 = 3,
        BUTCHERTYPE4 = 4,
        ButcherType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        ButcherType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool ButcherType_IsValid(int value);
    constexpr ButcherType ButcherType_MIN = NULL_BUTCHER_TYPE;
    constexpr ButcherType ButcherType_MAX = BUTCHERTYPE4;
    constexpr int ButcherType_ARRAYSIZE = ButcherType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ButcherType_descriptor();
    template<typename T>
    inline const std::string& ButcherType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ButcherType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ButcherType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            ButcherType_descriptor(), enum_t_value
        );
    }
    inline bool ButcherType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ButcherType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ButcherType>(
            ButcherType_descriptor(), name, value
        );
    }
    // ===================================================================

    // ===================================================================

    // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

    // @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

PROTOBUF_NAMESPACE_OPEN

template<>
struct is_proto_enum<::protobuf::PlaceType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::PlaceType>()
{
    return ::protobuf::PlaceType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::ShapeType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::ShapeType>()
{
    return ::protobuf::ShapeType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::PropType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::PropType>()
{
    return ::protobuf::PropType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::HumanBuffType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::HumanBuffType>()
{
    return ::protobuf::HumanBuffType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::ButcherBuffType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::ButcherBuffType>()
{
    return ::protobuf::ButcherBuffType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::PlayerType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::PlayerType>()
{
    return ::protobuf::PlayerType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::HumanType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::HumanType>()
{
    return ::protobuf::HumanType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::ButcherType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::ButcherType>()
{
    return ::protobuf::ButcherType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto
